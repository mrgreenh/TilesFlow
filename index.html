<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>TilesFlow</title>

    <link rel="stylesheet" href="./main.css">
</head>

<body>
    <div class="pageContainer">
        <section id="projectDescription">
            <h2>The Grid</h2>
            <p data-scrollToConf="points">
                First, you need a grid of points. But before that you'll need to run
                <pre>npm install git://github.com/mrgreenh/TilesFlow</pre>
                (I'll publish a npm module as soon as this thing stabilizes a tiny bit more). Then you are ready to go:
                <pre>
import TilesFlow from 'tilesflow';

var visualSettings = {
            pointsColor: [0,0,0,255]
        }
var tf = new TilesFlow("#containerId", [], visualSettings);
tf.render(0);
                </pre>
                The <code>#containerId</code> thinghy is the id of the element where you want this visualization to appear. A canvas element will be appended to it automatically. For example, you can use a <code>div</code> as a container.
            </p>

            <h2>Distances Between Points</h2>
            <p data-scrollToConf="step">
                What's the 0 in <code>tf.render(0)</code> you ask? That's the phase of the animation. It can be any number really, and TilesFlow will automatically coerce it into a number between 0 and <var>step</var>. <var>step</var> is 100 by default, but you can customize it by specifying a different value for it in visualSettings. It will change the resolution of the grid. What you see above is a <var>step</var> of 50.
            </p>

            <h2>Triangles</h2>
            <p data-ScrollToConf="triangles">
                These points are all connected by shapes. Right now only triangles are supported, because I'm lazy. Where are the triangles then? Add a stroke color to the visualSettings to see them!

                <pre>
var visualSettings = {
            stroke: [0,0,0,100],
            pointsColor: [0,255,0,255]
        }
                </pre>
            </p>

            <p>
                You might have some questions at this point. Why triangles? Or why is each odd column of points offsetted by half step? Well, the answer is: it's art. I liked it better that way. For example I wanted to use triangles, and having a grid like this allows me to have a more dense flow of triangles by using less points. Cuz points are expensive :/
            </p>

            <h2>Colors</h2>
            <p data-scrollToConf="colors">
                As you probably noticed by now, colors are expressed as four-dimensional vectors. And yeah, you guessed it, that's the RGBA space. All values go from 0 to 255. Now, I imagine you want to see some colors. You can set a color for the lines, a color for the points, and a color for the connecting triangles in the <var>visualSettings</var>:
                <pre>
var visualSettings = {
            stroke: [100,0,100,255],
            pointsColor: [200,0,200,255],
            baseColor: [250,250,0,100]
}
                </pre>
            </p>

            <h2>Forces</h2>
            <p>
                Now this is where it gets fun. You were probably wondering what is that <code>[]</code> that was left empty in <code>new TilesFlow("#containerId", [], visualSettings)</code>.
                That is the <var>forceField</var>.
            </p>
            <p data-scrollToConf="forces">
                Let's go ahead and give our visualization a forcefield to see what happens:

                <pre>
var forceField = [
    {
         x: 50,
         y: 40,
         decay: "linear",
         intensity: 100,
         influencePosition: true
   }
]

var visualConfig = {
    stroke: [100,0,100,255],
    pointsColor: [0,0,0,255],
    baseColor: [250,250,0,100],
    showForces: true,
    padding: [0,0,1,0]
}

var tf = new TilesFlow("#containerId", forceField, visualSettings);
tf.render(0);
                </pre>

            </p>
            <p>
                Cool uh? That red point in the middle of the canvas is the force. We see it thanks to the <var>showForces</var> option. It is pushing apart the points that get in its proximity with an <var>intensity</var> of 100. As a result also the triangles get distorted. It's x and y position are expressed in percentage, this means <code>x: 50, y: 50</code> would position the force in the middle of the canvas. 
            </p>
            <p>
                The <var>decay</var> is <var>linear</var>, which is the default option, but you can also use <var>cosine</var>, <var>sine</var> <var>clipping_power</var> at the time of writing.
                There is also a <var>inverse</var> key you can set to a boolean, it will invert the function influencing the points. This means further points will get influenced more strongly than closer points.
            </p>

            <p data-scrollToConf="padding">
                The <var>padding</var> option in the visual settings is just causing the lowest row of the dots to not be connected by any triangle. I added it because I didn't want the force to push any triangles outside of the viewport, to avoid that horrible-looking clipping.
            </p>

            <h2>Force and Colors</h2>
            <p data-scrollToConf="forces_colors">
                the <var>influencePosition</var> variable in the force configuration is indicating that the force will only influence the position of the points getting close to it. However it is possible to also add a <var>influenceColor</var> flag that will cause the force to interpolate the value of a given <var>color</var> key with the base color of the visualization.
            </p>
            <pre>
var forceField = [
    {
         x: 50,
         y: 40,
         decay: "linear",
         intensity: 100,
         influencePosition: true,
         influenceColor: true,
         color: [250, 0, 100, 250]
   }
]

var visualConfig = {
    stroke: [255,255,255,255],
    pointsColor: [0,0,0,255],
    baseColor: [50,100,50,50],
    showForces: true,
    padding: [0,0,1,0]
}
            </pre>

            <h2>More on colors...</h2>

            <p data-scrollToConf="more_on_colors">
                The visual settings also accept a <var>colorInterpolationMode</var> option. For now only 'addition' and 'subtraction' are supported. This is convenient if you want to reason in a negative way. Not in the sense you need to be sad, but in the sense that you might want to have a very light background and have the forces <strong>subtract</strong> their color instead.
            </p>

            <p>
                Also it is possible of course to specify forces not causing any spacial displacement and only influencing colors. 
            </p>

            <pre>
var forceField =[
    {
         x: 50,
         y: 40,
         decay: "linear",
         intensity: 100,
         influencePosition: true,
         influenceColor: true,
         color: [150, 0, 200, 0]
   },
   {
         x: 20,
         y: 60,
         decay: "cosine",
         intensity: 150,
         influenceColor: true,
         color: [100, 100, 50, 0]
   },
  {
         x: 80,
         y: -20,
         decay: "sine",
         intensity: 150,
         influenceColor: true,
         color: [100, 100, 50, 0]
   },
 {
         x: 60,
         y: 60,
         decay: "clipping_power",
         intensity: 200,
         influenceColor: true,
         color: [0, 200, 200, 0]
   }

];
var visualConfig = {
        stroke: [255,255,255,0],
        baseColor: [255,255,255,255],
        padding: [0,0,1,0],
        colorInterpolationMode: "subtraction"
};
            </pre>

            <h2>Patterns</h2>
            <p data-scrollToConf="patterns">
                What you are looking at right now looks like a piece of cloth. This is because the triangles connecting all points are covering the entire surface without overlapping. It is possible however to provide the <var>visualConfig</var> with a <var>pattern</var> key that specifies the way triangles are supposed to connect the dots. In theory, this lib can easily be extended to support connecting points with circles, or squares, or teddy bears. In theory. In practice, this is my little artistic project that I like to fill with triangles just because. :) However, if you'd like to use teddy bears instead, shoot me a Github issue or, even better, a pull request.
            </p>

            <p>
                Going back to triangles patterns, you can make this viz look like, for example, shards of broken glass, or some very intricated origami, by changing the pattern and tweaking the settings. I won't say there are infinite possibilities, because we are moving in a discrete space with limited resources hence there aren't, but there are quite enough as usual for anybody to have fun experimenting.
            </p>

            <pre>
var forceField = [
    {
         x: 50,
         y: 40,
         decay: "linear",
         intensity: 100,
         influencePosition: true,
         influenceColor: true,
         color: [150, 0, 200, 0]
   },
   {
         x: 35,
         y: 60,
         decay: "cosine",
         intensity: 80,
         influenceColor: true,
         color: [100, 100, 50, 0]
   },
  {
         x: 80,
         y: -20,
         decay: "sine",
         intensity: 90,
         influenceColor: true,
         color: [100, 100, 50, 0]
   },
 {
         x: 60,
         y: 60,
         decay: "clipping_power",
         intensity: 100,
         influenceColor: true,
         color: [0, 200, 200, 0]
   },

    {
         x: 55,
         y: 90,
         intensity: 100,
         influencePosition: true
   },

   {
         x: 30,
         y: 90,
         intensity: 100,
         influencePosition: true
   }

];
var visualConfig = {
        baseColor: [255,255,255,255],
        stroke: [50,50,50,50],
        padding: [0,0,2,0],
        colorInterpolationMode: "subtraction",
        pattern: TilesFlow.PATTERNS.brokenGlass
    }
}
            </pre>
            <p>
                That's all for now!
            </p>
            <h2>
                Enjoy!
            </h2>

        <footer>
            <p><a title="Github repo" href="https://github.com/mrgreenh/TilesFlow">Github repo of this thing</a></p>
            <p>Follow <a href="https://twitter.com/MrGreenH">@mrgreenh</a> on twitter.</p>
        </footer>

        </section>


        <div id="canvasContainer">
            <div id="pt" class="pt">
            </div>
            <div id="pt2" class="pt">
            </div>
        </div>

    </div>
    <script src="./dist/bundle.js"></script>
</body>

</html>